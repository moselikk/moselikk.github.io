<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="x-ua-compatible" content="ie=edge" />
  <title>
    JS 函数形参 arguments 的特点
  </title>
  <meta
    name="description"
    content="今天看到一个小题目，加深了我对函数 arguments 的理解function handleArr(arr) {    arr[0] = arr[2]}function foo(a, b, c) {    c = 10    handleArr(arguments)    return a + b + c}foo..."
  />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link
    rel="canonical"
    href="https://moselikk.com/blog/JS-arguments"
  />
  <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
  <link rel="stylesheet" href="/css/main.css">
  <link rel="alternate" type="application/rss+xml" title="moselikk"
  href="https://moselikk.com/feed.xml">
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>JS 函数形参 arguments 的特点 | moselikk</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="JS 函数形参 arguments 的特点" />
<meta name="author" content="Moselikk" />
<meta property="og:locale" content="zh_cmn_Hans" />
<meta name="description" content="今天看到一个小题目，加深了我对函数 arguments 的理解 function handleArr(arr) { arr[0] = arr[2] } function foo(a, b, c) { c = 10 handleArr(arguments) return a + b + c } foo(2, 2, 2) // 得到结果：22 在 JS 中函数参数变量和 arguments 是双向绑定的，改变参数变量 arguments 中的值会立即改变，改变 arguments 的值，参数变量也会响应改变。 拓展： arguments并不是一个真正的数组，而是一个类数组对象，意味着 arguments 有长度属性并且属性的索引是从零开始的，但是它除了 length 属性和索引元素之外没有任何 Array 属性，例如 forEach() 方法和 map() 方法都是没有的。 arguments 对象是所有（非箭头）函数中都可用的局部变量。你可以使用 arguments 对象在函数中引用函数的参数。此对象包含传递给函数的每个参数，第一个参数在索引 0 处。 如果调用的参数多于正式声明接受的参数，则可以使用 arguments 对象。这种技术对于可以传递可变数量的参数的函数很有用。使用 arguments.length 来确定传递给函数参数的个数，然后使用 arguments 对象来处理每个参数。 可以使用 Array.from() 方法或扩展运算符将参数转换为真实数组 var args = Array.from(arguments); var args = [...arguments]; 相关属性 arguments.callee 指向参数所属的当前执行的函数。 arguments.length 传递给函数的参数数量。 arguments[@@iterator] 返回一个新的 Array 迭代器 对象，该对象包含参数中每个索引的值。 当非严格模式中的函数有包含剩余参数、默认参数和解构赋值，那么 arguments 对象中的值不会跟踪参数的值（反之亦然）。 function func(a = 55) { arguments[0] = 99; // updating arguments[0] does not also update a console.log(a); } func(10); // 10" />
<meta property="og:description" content="今天看到一个小题目，加深了我对函数 arguments 的理解 function handleArr(arr) { arr[0] = arr[2] } function foo(a, b, c) { c = 10 handleArr(arguments) return a + b + c } foo(2, 2, 2) // 得到结果：22 在 JS 中函数参数变量和 arguments 是双向绑定的，改变参数变量 arguments 中的值会立即改变，改变 arguments 的值，参数变量也会响应改变。 拓展： arguments并不是一个真正的数组，而是一个类数组对象，意味着 arguments 有长度属性并且属性的索引是从零开始的，但是它除了 length 属性和索引元素之外没有任何 Array 属性，例如 forEach() 方法和 map() 方法都是没有的。 arguments 对象是所有（非箭头）函数中都可用的局部变量。你可以使用 arguments 对象在函数中引用函数的参数。此对象包含传递给函数的每个参数，第一个参数在索引 0 处。 如果调用的参数多于正式声明接受的参数，则可以使用 arguments 对象。这种技术对于可以传递可变数量的参数的函数很有用。使用 arguments.length 来确定传递给函数参数的个数，然后使用 arguments 对象来处理每个参数。 可以使用 Array.from() 方法或扩展运算符将参数转换为真实数组 var args = Array.from(arguments); var args = [...arguments]; 相关属性 arguments.callee 指向参数所属的当前执行的函数。 arguments.length 传递给函数的参数数量。 arguments[@@iterator] 返回一个新的 Array 迭代器 对象，该对象包含参数中每个索引的值。 当非严格模式中的函数有包含剩余参数、默认参数和解构赋值，那么 arguments 对象中的值不会跟踪参数的值（反之亦然）。 function func(a = 55) { arguments[0] = 99; // updating arguments[0] does not also update a console.log(a); } func(10); // 10" />
<link rel="canonical" href="https://moselikk.com/blog/JS-arguments" />
<meta property="og:url" content="https://moselikk.com/blog/JS-arguments" />
<meta property="og:site_name" content="moselikk" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-08-09T15:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="JS 函数形参 arguments 的特点" />
<meta name="google-site-verification" content="" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Moselikk"},"dateModified":"2022-08-09T15:00:00+08:00","datePublished":"2022-08-09T15:00:00+08:00","description":"今天看到一个小题目，加深了我对函数 arguments 的理解 function handleArr(arr) { arr[0] = arr[2] } function foo(a, b, c) { c = 10 handleArr(arguments) return a + b + c } foo(2, 2, 2) // 得到结果：22 在 JS 中函数参数变量和 arguments 是双向绑定的，改变参数变量 arguments 中的值会立即改变，改变 arguments 的值，参数变量也会响应改变。 拓展： arguments并不是一个真正的数组，而是一个类数组对象，意味着 arguments 有长度属性并且属性的索引是从零开始的，但是它除了 length 属性和索引元素之外没有任何 Array 属性，例如 forEach() 方法和 map() 方法都是没有的。 arguments 对象是所有（非箭头）函数中都可用的局部变量。你可以使用 arguments 对象在函数中引用函数的参数。此对象包含传递给函数的每个参数，第一个参数在索引 0 处。 如果调用的参数多于正式声明接受的参数，则可以使用 arguments 对象。这种技术对于可以传递可变数量的参数的函数很有用。使用 arguments.length 来确定传递给函数参数的个数，然后使用 arguments 对象来处理每个参数。 可以使用 Array.from() 方法或扩展运算符将参数转换为真实数组 var args = Array.from(arguments); var args = [...arguments]; 相关属性 arguments.callee 指向参数所属的当前执行的函数。 arguments.length 传递给函数的参数数量。 arguments[@@iterator] 返回一个新的 Array 迭代器 对象，该对象包含参数中每个索引的值。 当非严格模式中的函数有包含剩余参数、默认参数和解构赋值，那么 arguments 对象中的值不会跟踪参数的值（反之亦然）。 function func(a = 55) { arguments[0] = 99; // updating arguments[0] does not also update a console.log(a); } func(10); // 10","headline":"JS 函数形参 arguments 的特点","mainEntityOfPage":{"@type":"WebPage","@id":"https://moselikk.com/blog/JS-arguments"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://moselikk.com/apple-touch-icon.png"},"name":"Moselikk"},"url":"https://moselikk.com/blog/JS-arguments"}</script>
<!-- End Jekyll SEO tag -->

  <script>

  </script>
  <script>
  </script>
</head>

<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-K329WMFD');</script>
  <!-- End Google Tag Manager -->
<body>
  <!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K329WMFD"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->
  <div class="outer">
    <div class="page-content" id="article">
      <div class="wrapper">
        <div id="hitokoto" class="hitokoto">
          <a href="#" id="hitokoto_text">...... </a>
        </div>
        <div class="hanging-drop">
        </div>
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
      <header class="post-header">
    <h1 class="post-title" itemprop="name headline">JS 函数形参 arguments 的特点</h1>
    <p class="post-meta">
      <span><svg width="10px" height="10px" style="fill: #888; margin-right: 5px; vertical-align: baseline;" viewBox="0 0 16 16"><path d="M2.06 6.69c.14-.4.5-.69.94-.69h11V5c0-.55-.45-1-1-1H6.41l-1.7-1.71A.997.997 0 0 0 4 2H1c-.55 0-1 .45-1 1v9.84l2.05-6.15h.01zM16 8c0-.55-.45-1-1-1H4a.99.99 0 0 0-.94.69l-2 6c-.04.09-.06.2-.06.31 0 .55.45 1 1 1h11c.44 0 .81-.29.94-.69l2-6c.04-.09.06-.2.06-.31z"></path></svg>
      <time datetime="2022-08-09T15:00:00+08:00" itemprop="datePublished">Aug 9, 2022</time></span>
      <a href="/"><span><svg width="10px" height="10px" style="fill: #888; margin-right: 5px; vertical-align: baseline;" viewBox="0 0 16 16"><path d="M1 3h14c.55 0 1-.45 1-1s-.45-1-1-1H1c-.55 0-1 .45-1 1s.45 1 1 1zm14 10H1c-.55 0-1 .45-1 1s.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1zm0-4H1c-.55 0-1 .45-1 1s.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1zm0-4H1c-.55 0-1 .45-1 1s.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1z"></path></svg>Home</span></a>
      <a href="mailto:moselikk@gmail.com"><span><svg width="10px" height="10px" style="fill: #888; margin-right: 5px; vertical-align: baseline;" viewBox="0 0 16 16"><path d="M6 10c-1.1 0-2-.9-2-2V3H1c-.55 0-1 .45-1 1v8c0 .55.45 1 1 1v2a1.003 1.003 0 0 0 1.71.71L5.41 13H10c.55 0 1-.45 1-1v-1.17l-.83-.83H6zm9-10H6c-.55 0-1 .45-1 1v7c0 .55.45 1 1 1h4.59l2.71 2.71c.17.18.42.29.7.29.55 0 1-.45 1-1V9c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1z"></path></svg>Email</span></a>
      <a href="https://github.com/moselikk"><span><svg width="10px" height="10px" style="fill: #888; margin-right: 5px; vertical-align: baseline;" viewBox="0 0 16 16"><path d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>Github</span></a>
      <a href="/excerpt"><span><svg width="10px" height="10px" style="fill: #888; margin-right: 5px; vertical-align: baseline;" viewBox="0 0 16 16"><path d="M11 11c-.28 0-.53.11-.71.29L9 12.59V8c0-.55-.45-1-1-1s-1 .45-1 1v4.59L5.71 11.3A.965.965 0 0 0 5 11a1.003 1.003 0 0 0-.71 1.71l3 3c.18.18.43.29.71.29s.53-.11.71-.29l3-3A1.003 1.003 0 0 0 11 11zm1-7c-.03 0-.07 0-.1.01A5 5 0 0 0 2 5c0 .11.01.22.02.33A3.51 3.51 0 0 0 0 8.5c0 1.41.84 2.61 2.03 3.17C2.2 10.17 3.46 9 5 9c.06 0 .13.02.19.02C5.07 8.7 5 8.36 5 8c0-1.66 1.34-3 3-3s3 1.34 3 3c0 .36-.07.7-.19 1.02.06 0 .13-.02.19-.02 1.48 0 2.7 1.07 2.95 2.47A3.964 3.964 0 0 0 16 8c0-2.21-1.79-4-4-4z"></path></svg>Excerpt</span></a>
      <a href="/about"><span><svg xmlns="http://www.w3.org/2000/svg" width="10px" height="10px" style="fill: #888; margin-right: 5px; vertical-align: baseline;" viewBox="0 0 16 16"><!-- Icon from Tabler Icons by Paweł Kuna - https://github.com/tabler/tabler-icons/blob/master/LICENSE --><path fill="currentColor" d="M18.333 2c1.96 0 3.56 1.537 3.662 3.472l.005.195v12.666c0 1.96-1.537 3.56-3.472 3.662l-.195.005H5.667a3.667 3.667 0 0 1-3.662-3.472L2 18.333V5.667c0-1.96 1.537-3.56 3.472-3.662L5.667 2zM6 15a1 1 0 0 0-1 1v2l.007.117A1 1 0 0 0 7 18v-2l-.007-.117A1 1 0 0 0 6 15m3-4a1 1 0 0 0-1 1v6l.007.117A1 1 0 0 0 10 18v-6l-.007-.117A1 1 0 0 0 9 11m3 2a1 1 0 0 0-1 1v4l.007.117A1 1 0 0 0 13 18v-4l-.007-.117A1 1 0 0 0 12 13"/></svg>About</span></a>
    </p>
  </header>


  

  <div class="post-content" itemprop="articleBody">
    <p>今天看到一个小题目，加深了我对函数 arguments 的理解</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">handleArr</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nf">foo</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">c</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="nf">handleArr</span><span class="p">(</span><span class="nx">arguments</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span> <span class="o">+</span> <span class="nx">c</span>
<span class="p">}</span>
<span class="nf">foo</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">// 得到结果：22</span>
</code></pre></div></div>
<ul>
  <li>在 JS 中函数参数变量和 arguments 是双向绑定的，改变参数变量 arguments 中的值会立即改变，改变 arguments 的值，参数变量也会响应改变。</li>
</ul>

<h2 id="拓展">拓展：</h2>

<ul>
  <li>arguments并不是一个真正的数组，而是一个类数组对象，意味着 arguments 有长度属性并且属性的索引是从零开始的，但是它除了 length 属性和索引元素之外没有任何 Array 属性，例如 forEach() 方法和 map() 方法都是没有的。</li>
  <li>arguments 对象是所有（非箭头）函数中都可用的局部变量。你可以使用 arguments 对象在函数中引用函数的参数。此对象包含传递给函数的每个参数，第一个参数在索引 0 处。</li>
  <li>如果调用的参数多于正式声明接受的参数，则可以使用 arguments 对象。这种技术对于可以传递可变数量的参数的函数很有用。使用 arguments.length 来确定传递给函数参数的个数，然后使用 arguments 对象来处理每个参数。</li>
  <li>可以使用 Array.from() 方法或扩展运算符将参数转换为真实数组
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">arguments</span><span class="p">];</span>
</code></pre></div>    </div>
  </li>
  <li>相关属性
    <ul>
      <li>arguments.callee  指向参数所属的当前执行的函数。</li>
      <li>arguments.length  传递给函数的参数数量。</li>
      <li>arguments[@@iterator] 返回一个新的 Array 迭代器 对象，该对象包含参数中每个索引的值。</li>
    </ul>
  </li>
  <li>当非严格模式中的函数有包含剩余参数、默认参数和解构赋值，那么 arguments 对象中的值不会跟踪参数的值（反之亦然）。
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">func</span><span class="p">(</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">55</span><span class="p">)</span> <span class="p">{</span>
<span class="nx">arguments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">99</span><span class="p">;</span> <span class="c1">// updating arguments[0] does not also update a</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
<span class="p">}</span>
<span class="nf">func</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// 10</span>
</code></pre></div>    </div>
  </li>
</ul>

  </div>
<!-- Gitalk 评论系统 -->

<div id="gitalk-container"></div>
<script>
  const gitalk = new Gitalk({
    clientID: '',
    clientSecret: '',
    repo: 'moselikk/moselikk.github.io',
    owner: 'moselikk',
    admin: '["moselikk"]',
    id: 'https://moselikk.com/blog/JS-arguments', // Ensure uniqueness and length less than 50
    distractionFreeMode: 'false' // Facebook-like distraction free mode
  })
  gitalk.render('gitalk-container')
</script>

</article>

      </div>
    </div>
  </div>
  <script>
    // open outbound links in new tab
    let origin = document.location.origin;
    let links = document.getElementsByTagName("a");
    for (let link of links) {
      if (
        link.href &&
        link.href.indexOf(origin) != 0 &&
        !link.href.includes("mailto:")
      )
        link.setAttribute("target", "_blank");
    }

    // responsive table
    let tables = document.getElementsByTagName("table");
    for (let table of tables) {
      let ths = table.tHead.rows[0].cells;
      let trs = table.tBodies[0].rows;
      for (let row of trs) {
        for (let i = 0; i < row.cells.length; i++) {
          row.cells[i].setAttribute("data-label", ths[i].textContent);
        }
      }
    }

    // hitokoto api
    const rule = ["a", "b","c","d","h","i","j","k"];
    const query = rule.map(item => `c=${item}`).join('&');

      // Function to fetch hitokoto
      function fetchHitokoto() {
      fetch(`https://v1.hitokoto.cn?${query}`)
        .then((response) => response.json())
        .then((data) => {
          const hitokoto = document.getElementById("hitokoto_text");
          hitokoto.href = "https://hitokoto.cn/?uuid=" + data.uuid;
          const from = data.from ? " -" + data.from : ''
          hitokoto.innerText = data.hitokoto + from;
          // Store the timestamp and result of the last API call
          localStorage.setItem('lastHitokotoCall', Date.now());
          localStorage.setItem('lastHitokotoResult', JSON.stringify(data));
        })
        .catch(console.error);
    }

    // Function to use the last hitokoto result
    function useLastHitokotoResult() {
      const data = JSON.parse(localStorage.getItem('lastHitokotoResult'));
      const hitokoto = document.getElementById("hitokoto_text");
      hitokoto.href = "https://hitokoto.cn/?uuid=" + data.uuid;
      hitokoto.innerText = data.hitokoto;
    }

    // Check if we can call the API
    function canCallHitokoto() {
      const lastCall = localStorage.getItem('lastHitokotoCall');
      const now = Date.now();
      // Check if the last call was more than a minute ago
      return !lastCall || now - lastCall > 60 * 1000;
    }

    // Main logic
    if (canCallHitokoto()) {
      fetchHitokoto();
    } else {
      const lastResult = localStorage.getItem('lastHitokotoResult');
      if (lastResult) {
        useLastHitokotoResult();
      } else {
        fetchHitokoto();
      }
    }
  </script>
  <!-- <script src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon='{"token": ""}'
    onerror="gtag('set', 'user_properties', {blocker: 'true'});"></script> -->
  <script src="/js/zooming.min.js"></script>
  <script>
    if (window.Zooming && typeof screen.orientation == "undefined")
      window.addEventListener("load", function () {
        new Zooming().listen(".post-content img");
      });
  </script>
  <script src="../js/denglong.js"></script>
</body>

</html>