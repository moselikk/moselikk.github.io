<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="x-ua-compatible" content="ie=edge" />
  <title>
    Git 常用命令速查
  </title>
  <meta
    name="description"
    content="Git 官网：https://git-scm.com/官方文档：https://git-scm.com/docs阮一峰整理：https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html全部命令： https://git-scm.com/docs/git#..."
  />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link
    rel="canonical"
    href="https://moselikk.com/blog/git-commands"
  />
  <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
  <link rel="stylesheet" href="/css/main.css">
  <link rel="alternate" type="application/rss+xml" title="moselikk"
  href="https://moselikk.com/feed.xml">
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Git 常用命令速查 | moselikk</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Git 常用命令速查" />
<meta name="author" content="Moselikk" />
<meta property="og:locale" content="zh_cmn_Hans" />
<meta name="description" content="Git 官网：https://git-scm.com/ 官方文档：https://git-scm.com/docs 阮一峰整理：https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html 全部命令： https://git-scm.com/docs/git#_git_commands GitHub Cheat Sheet：https://training.github.com/ 创建仓库 创建仓库有多种方式，可以直接复制一个已经创建好的仓库的全部文件，git 即刻可用；可以从 github 等远程仓库 clone，克隆的项目 git 也是就绪的；可以使用git init初始化本地 git 仓库。 $ git init 将所在目录初始化为一个 git 仓库 $ git init [project-name] 新建一个目录，将其初始化为 Git 仓库 $ git remote add origin [url] 链接本地仓库与远程仓库 $ git clone [url] Clone（下载）一个已存在于的仓库和它的整个代码历史 Git配置 Git的设置文件为 .gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置） $ git config --list 显示当前的 Git 配置 $ git config --global user.name &quot;[name]&quot; 对你的 commit 操作设置关联的用户名 $ git config --global user.email &quot;[email address]&quot; 对你的 commit 操作设置关联的邮箱地址 $ git config --global color.ui auto 启用有帮助的彩色命令行输出 分支 $ git branch 列出所有本地分支 $ git branch -r 列出所有远程分支 $ git branch -a 列出所有本地分支和远程分支 $ git branch [branch-name] 创建分支（但依然停留在当前分支） $ git checkout -b [branch] 新建一个分支，并切换到该分支 $ git checkout [branch-name] 切换到指定分支，并更新工作区 $ git switch -c [branch-name] 切换到指定分支并更新工作目录 （working directory）（&gt;git 2.23） $ git checkout - 切换到上一个分支 $ git merge [branch] 将指定分支的历史合并到当前分支。这通常在拉取请求(PR)中完成，但也是一个重要的 Git 操作。 $ git cherry-pick [commit] 选择一个 commit，合并进当前分支 $ git branch -d [branch-name] 删除指定分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] 删除远程分支 增加/删除文件 $ git add [file1] [file2] ... 添加指定文件到暂存区 $ git add [dir] 添加指定目录到暂存区，包括目录下所有子目录及文件 $ git add . 添加当前目录的所有文件到暂存区 $ git add -p 添加每个变化前，都会要求确认；对于同一个文件的多处变化，可以实现分次提交（细颗粒度的控制） $ git rm [file1] [file2] ... 删除工作区文件，并且将这次删除放入暂存区 $ git rm --cached [file] 停止追踪指定文件，但该文件会保留在工作区 $ git mv [file-original] [file-renamed] 改名文件，并且将这个改名放入暂存区 代码提交 $ git commit -m [message] 提交暂存区到仓库区 $ git commit [file1] [file2] ... -m [message] 提交暂存区的指定文件到仓库区 $ git commit -a 提交工作区自上次 commit 之后的变化，直接到仓库区 $ git commit -v 提交时显示所有 diff 信息 $ git commit --amend -m [message] 使用一次新的 commit，替代上一次提交 如果代码没有任何新变化，则用来改写上一次 commit 的提交信息 $ git commit --amend [file1] [file2] ... 重做上一次 commit，并包括指定文件的新变化 远程同步 $ git fetch [remote] 下载远程仓库的所有变动 $ git remote -v 显示所有远程仓库 $ git remote show [remote] 显示某个远程仓库的信息 $ git remote add [shortname] [url] 增加一个新的远程仓库，并命名 $ git pull [remote] [branch] 取回远程仓库的变化，并与本地分支合并 $ git push [remote] [branch] 上传本地指定分支到远程仓库 $ git push [remote] --force 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --all 推送所有分支到远程仓库 $ git push --set-upstream origin my-branch 将本地创建的分支推送到远程仓库 撤销 $ git checkout [file] 恢复暂存区的指定文件到工作区（撤销对 file 文件的修改） $ git checkout [commit] [file] 恢复某个 commit 的指定文件到暂存区和工作区 $ git checkout . 恢复暂存区的所有文件到工作区 $ git reset [file] 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变 $ git reset --hard 重置暂存区与工作区，与上一次 commit 保持一致 $ git reset [commit] 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变 $ git reset --hard [commit] 重置当前分支的 HEAD 为指定 commit，同时重置暂存区和工作区，与指定 commit 一致 $ git reset --keep [commit] 重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变 $ git revert [commit] 新建一个 commit，用来撤销指定 commit 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git stash $ git stash pop 暂时将未提交的变化移除，稍后再移入 $ git reset HEAD^ 上次提交内容会被保存到工作目录 $ git reset --hard HEAD^ 上次提交内容会被直接丢弃 标签 $ git tag 列出所有 tag $ git tag [tag] 新建一个 tag 在当前 commit $ git tag [tag] [commit] 新建一个 tag 在指定 commit $ git tag -d [tag] 删除本地 tag $ git push origin :refs/tags/[tagName] 删除远程 tag $ git show [tag] 查看 tag 信息 $ git push [remote] [tag] 提交指定 tag $ git push [remote] --tags 提交所有 tag $ git checkout -b [branch] [tag] 新建一个分支，指向某个 tag 查看信息 $ git status 显示有变更的文件 $ git log 显示当前分支的版本历史 $ git log --stat 显示 commit 历史，以及每次 commit 发生变更的文件 $ git log -S [keyword] 搜索提交历史，根据关键词 $ git log [tag] HEAD --pretty=format:%s 显示某个 commit 之后的所有变动，每个 commit 占据一行 $ git log [tag] HEAD --grep feature 显示某个 commit 之后的所有变动，其”提交说明”必须符合搜索条件 $ git log --follow [file] $ git whatchanged [file] 显示某个文件的版本历史，包括文件改名 $ git log -p [file] 显示指定文件相关的每一次 diff $ git log -5 --pretty --oneline 显示过去 5 次提交 $ git shortlog -sn 显示所有提交过的用户，按提交次数排序 $ git blame [file] 显示指定文件是什么人在什么时间修改过 $ git diff 显示暂存区和工作区的差异 $ git diff --cached [file] 显示暂存区和上一个 commit 的差异 $ git diff HEAD 显示工作区与当前分支最新 commit 之间的差异 $ git diff [first-branch]...[second-branch] 显示两次提交之间的差异 $ git diff --shortstat &quot;@{0 day ago}&quot; 显示今天你写了多少行代码 $ git show [commit] 显示某次提交的元数据和内容变化 $ git show --name-only [commit] 显示某次提交发生变化的文件 $ git show [commit]:[filename] 显示某次提交时，某个文件的内容 $ git reflog 显示当前分支的最近几次提交 命令行中图形化显示提交日志 $ git log --graph --oneline 图形化显示当前分支的提交日志 $ git log --graph --patch 图形化显示当前分支的提交日志及每次提交的变更内容 $ git log --graph --oneline --all 图形化显示所有分支的提交日志 $ git log --graph --patch --all 图形化显示所有分支的提交日志及每次提交的变更内容 Git diff $ git diff 比较当前工作区和 Git 的 staging area 里内容的区别 $ git diff --staged 比较 Git 的 staging area 和当前分支指向内容的区别 $ git diff &lt;commit&gt; &lt;commit&gt; 比较任意两次提交指向内容的区别 git checkout 和 git switch 的区别 是这样的，git checkout 是用于创建和切换分支的旧命令。它还可以用于恢复来自某个提交的修改。但是 git checkout 能做的不仅仅是这些，它还可以让你从任何分支复制文件或直接提交到当前工作区中，而无需切换分支。 实际上，git checkout 做了三件事情： 1）切换分支； 2）从暂存区复制文件到工作区（放弃当前修改）； 3）从其他区复制文件到工作区； 如果你不明白，那没关系，只需要记住：git checkout 能做的不仅仅是分支的切换，还有很多其他额外的功能，而这些额外的功能，增加了 git checkout 这个命令的复杂性。 因此，从 git 2.23 版本发布以后，引入了两个新的命令：git switch 和 git restore。 这样做的目的，是为了让人们使用 git switch 来切换分支，使用 git restore 来撤销本地修改。与此同时，git checkout 仍然被保存，用于提供更高级的选项来处理各种更加复杂的操作。 如果是切换分支，请使用 git switch 命令而不是 git checkout。为什么？因为它就是为这个特定任务创建的。对于新的 git 用户，更容易记住 git switch 用于切换分支，git restore 用于恢复修改。 因此，对于切换和创建分支这个操作来说，使用 git switch 命令替代 git checkout 是被提倡的做法。 git 修改 .gitignore 文件 不生效 原因是 .gitignore 只能忽略那些原来没有被 track 的文件，如果某些文件已经被纳入了版本管理中，则修改 .gitignore 是无效的。那么解决方法就是先把本地缓存删除（改变成未 track 状态），然后再提交： git rm -r --cached . git add . git commit -m &#39;update .gitignore&#39; 停止追踪某文件，重点命令 $ git rm —cached -r [file] 停止追踪指定文件，但该文件会保留在工作区 commit 之后 git 自动将 lf 转换成 crlf，导致行末 eslint 飘黄 修改 git 全局配置，禁止 git 自动将 lf 转换成 crlf git config --global core.autocrlf false" />
<meta property="og:description" content="Git 官网：https://git-scm.com/ 官方文档：https://git-scm.com/docs 阮一峰整理：https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html 全部命令： https://git-scm.com/docs/git#_git_commands GitHub Cheat Sheet：https://training.github.com/ 创建仓库 创建仓库有多种方式，可以直接复制一个已经创建好的仓库的全部文件，git 即刻可用；可以从 github 等远程仓库 clone，克隆的项目 git 也是就绪的；可以使用git init初始化本地 git 仓库。 $ git init 将所在目录初始化为一个 git 仓库 $ git init [project-name] 新建一个目录，将其初始化为 Git 仓库 $ git remote add origin [url] 链接本地仓库与远程仓库 $ git clone [url] Clone（下载）一个已存在于的仓库和它的整个代码历史 Git配置 Git的设置文件为 .gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置） $ git config --list 显示当前的 Git 配置 $ git config --global user.name &quot;[name]&quot; 对你的 commit 操作设置关联的用户名 $ git config --global user.email &quot;[email address]&quot; 对你的 commit 操作设置关联的邮箱地址 $ git config --global color.ui auto 启用有帮助的彩色命令行输出 分支 $ git branch 列出所有本地分支 $ git branch -r 列出所有远程分支 $ git branch -a 列出所有本地分支和远程分支 $ git branch [branch-name] 创建分支（但依然停留在当前分支） $ git checkout -b [branch] 新建一个分支，并切换到该分支 $ git checkout [branch-name] 切换到指定分支，并更新工作区 $ git switch -c [branch-name] 切换到指定分支并更新工作目录 （working directory）（&gt;git 2.23） $ git checkout - 切换到上一个分支 $ git merge [branch] 将指定分支的历史合并到当前分支。这通常在拉取请求(PR)中完成，但也是一个重要的 Git 操作。 $ git cherry-pick [commit] 选择一个 commit，合并进当前分支 $ git branch -d [branch-name] 删除指定分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] 删除远程分支 增加/删除文件 $ git add [file1] [file2] ... 添加指定文件到暂存区 $ git add [dir] 添加指定目录到暂存区，包括目录下所有子目录及文件 $ git add . 添加当前目录的所有文件到暂存区 $ git add -p 添加每个变化前，都会要求确认；对于同一个文件的多处变化，可以实现分次提交（细颗粒度的控制） $ git rm [file1] [file2] ... 删除工作区文件，并且将这次删除放入暂存区 $ git rm --cached [file] 停止追踪指定文件，但该文件会保留在工作区 $ git mv [file-original] [file-renamed] 改名文件，并且将这个改名放入暂存区 代码提交 $ git commit -m [message] 提交暂存区到仓库区 $ git commit [file1] [file2] ... -m [message] 提交暂存区的指定文件到仓库区 $ git commit -a 提交工作区自上次 commit 之后的变化，直接到仓库区 $ git commit -v 提交时显示所有 diff 信息 $ git commit --amend -m [message] 使用一次新的 commit，替代上一次提交 如果代码没有任何新变化，则用来改写上一次 commit 的提交信息 $ git commit --amend [file1] [file2] ... 重做上一次 commit，并包括指定文件的新变化 远程同步 $ git fetch [remote] 下载远程仓库的所有变动 $ git remote -v 显示所有远程仓库 $ git remote show [remote] 显示某个远程仓库的信息 $ git remote add [shortname] [url] 增加一个新的远程仓库，并命名 $ git pull [remote] [branch] 取回远程仓库的变化，并与本地分支合并 $ git push [remote] [branch] 上传本地指定分支到远程仓库 $ git push [remote] --force 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --all 推送所有分支到远程仓库 $ git push --set-upstream origin my-branch 将本地创建的分支推送到远程仓库 撤销 $ git checkout [file] 恢复暂存区的指定文件到工作区（撤销对 file 文件的修改） $ git checkout [commit] [file] 恢复某个 commit 的指定文件到暂存区和工作区 $ git checkout . 恢复暂存区的所有文件到工作区 $ git reset [file] 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变 $ git reset --hard 重置暂存区与工作区，与上一次 commit 保持一致 $ git reset [commit] 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变 $ git reset --hard [commit] 重置当前分支的 HEAD 为指定 commit，同时重置暂存区和工作区，与指定 commit 一致 $ git reset --keep [commit] 重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变 $ git revert [commit] 新建一个 commit，用来撤销指定 commit 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git stash $ git stash pop 暂时将未提交的变化移除，稍后再移入 $ git reset HEAD^ 上次提交内容会被保存到工作目录 $ git reset --hard HEAD^ 上次提交内容会被直接丢弃 标签 $ git tag 列出所有 tag $ git tag [tag] 新建一个 tag 在当前 commit $ git tag [tag] [commit] 新建一个 tag 在指定 commit $ git tag -d [tag] 删除本地 tag $ git push origin :refs/tags/[tagName] 删除远程 tag $ git show [tag] 查看 tag 信息 $ git push [remote] [tag] 提交指定 tag $ git push [remote] --tags 提交所有 tag $ git checkout -b [branch] [tag] 新建一个分支，指向某个 tag 查看信息 $ git status 显示有变更的文件 $ git log 显示当前分支的版本历史 $ git log --stat 显示 commit 历史，以及每次 commit 发生变更的文件 $ git log -S [keyword] 搜索提交历史，根据关键词 $ git log [tag] HEAD --pretty=format:%s 显示某个 commit 之后的所有变动，每个 commit 占据一行 $ git log [tag] HEAD --grep feature 显示某个 commit 之后的所有变动，其”提交说明”必须符合搜索条件 $ git log --follow [file] $ git whatchanged [file] 显示某个文件的版本历史，包括文件改名 $ git log -p [file] 显示指定文件相关的每一次 diff $ git log -5 --pretty --oneline 显示过去 5 次提交 $ git shortlog -sn 显示所有提交过的用户，按提交次数排序 $ git blame [file] 显示指定文件是什么人在什么时间修改过 $ git diff 显示暂存区和工作区的差异 $ git diff --cached [file] 显示暂存区和上一个 commit 的差异 $ git diff HEAD 显示工作区与当前分支最新 commit 之间的差异 $ git diff [first-branch]...[second-branch] 显示两次提交之间的差异 $ git diff --shortstat &quot;@{0 day ago}&quot; 显示今天你写了多少行代码 $ git show [commit] 显示某次提交的元数据和内容变化 $ git show --name-only [commit] 显示某次提交发生变化的文件 $ git show [commit]:[filename] 显示某次提交时，某个文件的内容 $ git reflog 显示当前分支的最近几次提交 命令行中图形化显示提交日志 $ git log --graph --oneline 图形化显示当前分支的提交日志 $ git log --graph --patch 图形化显示当前分支的提交日志及每次提交的变更内容 $ git log --graph --oneline --all 图形化显示所有分支的提交日志 $ git log --graph --patch --all 图形化显示所有分支的提交日志及每次提交的变更内容 Git diff $ git diff 比较当前工作区和 Git 的 staging area 里内容的区别 $ git diff --staged 比较 Git 的 staging area 和当前分支指向内容的区别 $ git diff &lt;commit&gt; &lt;commit&gt; 比较任意两次提交指向内容的区别 git checkout 和 git switch 的区别 是这样的，git checkout 是用于创建和切换分支的旧命令。它还可以用于恢复来自某个提交的修改。但是 git checkout 能做的不仅仅是这些，它还可以让你从任何分支复制文件或直接提交到当前工作区中，而无需切换分支。 实际上，git checkout 做了三件事情： 1）切换分支； 2）从暂存区复制文件到工作区（放弃当前修改）； 3）从其他区复制文件到工作区； 如果你不明白，那没关系，只需要记住：git checkout 能做的不仅仅是分支的切换，还有很多其他额外的功能，而这些额外的功能，增加了 git checkout 这个命令的复杂性。 因此，从 git 2.23 版本发布以后，引入了两个新的命令：git switch 和 git restore。 这样做的目的，是为了让人们使用 git switch 来切换分支，使用 git restore 来撤销本地修改。与此同时，git checkout 仍然被保存，用于提供更高级的选项来处理各种更加复杂的操作。 如果是切换分支，请使用 git switch 命令而不是 git checkout。为什么？因为它就是为这个特定任务创建的。对于新的 git 用户，更容易记住 git switch 用于切换分支，git restore 用于恢复修改。 因此，对于切换和创建分支这个操作来说，使用 git switch 命令替代 git checkout 是被提倡的做法。 git 修改 .gitignore 文件 不生效 原因是 .gitignore 只能忽略那些原来没有被 track 的文件，如果某些文件已经被纳入了版本管理中，则修改 .gitignore 是无效的。那么解决方法就是先把本地缓存删除（改变成未 track 状态），然后再提交： git rm -r --cached . git add . git commit -m &#39;update .gitignore&#39; 停止追踪某文件，重点命令 $ git rm —cached -r [file] 停止追踪指定文件，但该文件会保留在工作区 commit 之后 git 自动将 lf 转换成 crlf，导致行末 eslint 飘黄 修改 git 全局配置，禁止 git 自动将 lf 转换成 crlf git config --global core.autocrlf false" />
<link rel="canonical" href="https://moselikk.com/blog/git-commands" />
<meta property="og:url" content="https://moselikk.com/blog/git-commands" />
<meta property="og:site_name" content="moselikk" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-10-30T19:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Git 常用命令速查" />
<meta name="google-site-verification" content="" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Moselikk"},"dateModified":"2022-10-30T19:00:00+08:00","datePublished":"2022-10-30T19:00:00+08:00","description":"Git 官网：https://git-scm.com/ 官方文档：https://git-scm.com/docs 阮一峰整理：https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html 全部命令： https://git-scm.com/docs/git#_git_commands GitHub Cheat Sheet：https://training.github.com/ 创建仓库 创建仓库有多种方式，可以直接复制一个已经创建好的仓库的全部文件，git 即刻可用；可以从 github 等远程仓库 clone，克隆的项目 git 也是就绪的；可以使用git init初始化本地 git 仓库。 $ git init 将所在目录初始化为一个 git 仓库 $ git init [project-name] 新建一个目录，将其初始化为 Git 仓库 $ git remote add origin [url] 链接本地仓库与远程仓库 $ git clone [url] Clone（下载）一个已存在于的仓库和它的整个代码历史 Git配置 Git的设置文件为 .gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置） $ git config --list 显示当前的 Git 配置 $ git config --global user.name &quot;[name]&quot; 对你的 commit 操作设置关联的用户名 $ git config --global user.email &quot;[email address]&quot; 对你的 commit 操作设置关联的邮箱地址 $ git config --global color.ui auto 启用有帮助的彩色命令行输出 分支 $ git branch 列出所有本地分支 $ git branch -r 列出所有远程分支 $ git branch -a 列出所有本地分支和远程分支 $ git branch [branch-name] 创建分支（但依然停留在当前分支） $ git checkout -b [branch] 新建一个分支，并切换到该分支 $ git checkout [branch-name] 切换到指定分支，并更新工作区 $ git switch -c [branch-name] 切换到指定分支并更新工作目录 （working directory）（&gt;git 2.23） $ git checkout - 切换到上一个分支 $ git merge [branch] 将指定分支的历史合并到当前分支。这通常在拉取请求(PR)中完成，但也是一个重要的 Git 操作。 $ git cherry-pick [commit] 选择一个 commit，合并进当前分支 $ git branch -d [branch-name] 删除指定分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] 删除远程分支 增加/删除文件 $ git add [file1] [file2] ... 添加指定文件到暂存区 $ git add [dir] 添加指定目录到暂存区，包括目录下所有子目录及文件 $ git add . 添加当前目录的所有文件到暂存区 $ git add -p 添加每个变化前，都会要求确认；对于同一个文件的多处变化，可以实现分次提交（细颗粒度的控制） $ git rm [file1] [file2] ... 删除工作区文件，并且将这次删除放入暂存区 $ git rm --cached [file] 停止追踪指定文件，但该文件会保留在工作区 $ git mv [file-original] [file-renamed] 改名文件，并且将这个改名放入暂存区 代码提交 $ git commit -m [message] 提交暂存区到仓库区 $ git commit [file1] [file2] ... -m [message] 提交暂存区的指定文件到仓库区 $ git commit -a 提交工作区自上次 commit 之后的变化，直接到仓库区 $ git commit -v 提交时显示所有 diff 信息 $ git commit --amend -m [message] 使用一次新的 commit，替代上一次提交 如果代码没有任何新变化，则用来改写上一次 commit 的提交信息 $ git commit --amend [file1] [file2] ... 重做上一次 commit，并包括指定文件的新变化 远程同步 $ git fetch [remote] 下载远程仓库的所有变动 $ git remote -v 显示所有远程仓库 $ git remote show [remote] 显示某个远程仓库的信息 $ git remote add [shortname] [url] 增加一个新的远程仓库，并命名 $ git pull [remote] [branch] 取回远程仓库的变化，并与本地分支合并 $ git push [remote] [branch] 上传本地指定分支到远程仓库 $ git push [remote] --force 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --all 推送所有分支到远程仓库 $ git push --set-upstream origin my-branch 将本地创建的分支推送到远程仓库 撤销 $ git checkout [file] 恢复暂存区的指定文件到工作区（撤销对 file 文件的修改） $ git checkout [commit] [file] 恢复某个 commit 的指定文件到暂存区和工作区 $ git checkout . 恢复暂存区的所有文件到工作区 $ git reset [file] 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变 $ git reset --hard 重置暂存区与工作区，与上一次 commit 保持一致 $ git reset [commit] 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变 $ git reset --hard [commit] 重置当前分支的 HEAD 为指定 commit，同时重置暂存区和工作区，与指定 commit 一致 $ git reset --keep [commit] 重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变 $ git revert [commit] 新建一个 commit，用来撤销指定 commit 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git stash $ git stash pop 暂时将未提交的变化移除，稍后再移入 $ git reset HEAD^ 上次提交内容会被保存到工作目录 $ git reset --hard HEAD^ 上次提交内容会被直接丢弃 标签 $ git tag 列出所有 tag $ git tag [tag] 新建一个 tag 在当前 commit $ git tag [tag] [commit] 新建一个 tag 在指定 commit $ git tag -d [tag] 删除本地 tag $ git push origin :refs/tags/[tagName] 删除远程 tag $ git show [tag] 查看 tag 信息 $ git push [remote] [tag] 提交指定 tag $ git push [remote] --tags 提交所有 tag $ git checkout -b [branch] [tag] 新建一个分支，指向某个 tag 查看信息 $ git status 显示有变更的文件 $ git log 显示当前分支的版本历史 $ git log --stat 显示 commit 历史，以及每次 commit 发生变更的文件 $ git log -S [keyword] 搜索提交历史，根据关键词 $ git log [tag] HEAD --pretty=format:%s 显示某个 commit 之后的所有变动，每个 commit 占据一行 $ git log [tag] HEAD --grep feature 显示某个 commit 之后的所有变动，其”提交说明”必须符合搜索条件 $ git log --follow [file] $ git whatchanged [file] 显示某个文件的版本历史，包括文件改名 $ git log -p [file] 显示指定文件相关的每一次 diff $ git log -5 --pretty --oneline 显示过去 5 次提交 $ git shortlog -sn 显示所有提交过的用户，按提交次数排序 $ git blame [file] 显示指定文件是什么人在什么时间修改过 $ git diff 显示暂存区和工作区的差异 $ git diff --cached [file] 显示暂存区和上一个 commit 的差异 $ git diff HEAD 显示工作区与当前分支最新 commit 之间的差异 $ git diff [first-branch]...[second-branch] 显示两次提交之间的差异 $ git diff --shortstat &quot;@{0 day ago}&quot; 显示今天你写了多少行代码 $ git show [commit] 显示某次提交的元数据和内容变化 $ git show --name-only [commit] 显示某次提交发生变化的文件 $ git show [commit]:[filename] 显示某次提交时，某个文件的内容 $ git reflog 显示当前分支的最近几次提交 命令行中图形化显示提交日志 $ git log --graph --oneline 图形化显示当前分支的提交日志 $ git log --graph --patch 图形化显示当前分支的提交日志及每次提交的变更内容 $ git log --graph --oneline --all 图形化显示所有分支的提交日志 $ git log --graph --patch --all 图形化显示所有分支的提交日志及每次提交的变更内容 Git diff $ git diff 比较当前工作区和 Git 的 staging area 里内容的区别 $ git diff --staged 比较 Git 的 staging area 和当前分支指向内容的区别 $ git diff &lt;commit&gt; &lt;commit&gt; 比较任意两次提交指向内容的区别 git checkout 和 git switch 的区别 是这样的，git checkout 是用于创建和切换分支的旧命令。它还可以用于恢复来自某个提交的修改。但是 git checkout 能做的不仅仅是这些，它还可以让你从任何分支复制文件或直接提交到当前工作区中，而无需切换分支。 实际上，git checkout 做了三件事情： 1）切换分支； 2）从暂存区复制文件到工作区（放弃当前修改）； 3）从其他区复制文件到工作区； 如果你不明白，那没关系，只需要记住：git checkout 能做的不仅仅是分支的切换，还有很多其他额外的功能，而这些额外的功能，增加了 git checkout 这个命令的复杂性。 因此，从 git 2.23 版本发布以后，引入了两个新的命令：git switch 和 git restore。 这样做的目的，是为了让人们使用 git switch 来切换分支，使用 git restore 来撤销本地修改。与此同时，git checkout 仍然被保存，用于提供更高级的选项来处理各种更加复杂的操作。 如果是切换分支，请使用 git switch 命令而不是 git checkout。为什么？因为它就是为这个特定任务创建的。对于新的 git 用户，更容易记住 git switch 用于切换分支，git restore 用于恢复修改。 因此，对于切换和创建分支这个操作来说，使用 git switch 命令替代 git checkout 是被提倡的做法。 git 修改 .gitignore 文件 不生效 原因是 .gitignore 只能忽略那些原来没有被 track 的文件，如果某些文件已经被纳入了版本管理中，则修改 .gitignore 是无效的。那么解决方法就是先把本地缓存删除（改变成未 track 状态），然后再提交： git rm -r --cached . git add . git commit -m &#39;update .gitignore&#39; 停止追踪某文件，重点命令 $ git rm —cached -r [file] 停止追踪指定文件，但该文件会保留在工作区 commit 之后 git 自动将 lf 转换成 crlf，导致行末 eslint 飘黄 修改 git 全局配置，禁止 git 自动将 lf 转换成 crlf git config --global core.autocrlf false","headline":"Git 常用命令速查","mainEntityOfPage":{"@type":"WebPage","@id":"https://moselikk.com/blog/git-commands"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://moselikk.com/apple-touch-icon.png"},"name":"Moselikk"},"url":"https://moselikk.com/blog/git-commands"}</script>
<!-- End Jekyll SEO tag -->

  <script>

  </script>
  <script>
  </script>
</head>

<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-K329WMFD');</script>
  <!-- End Google Tag Manager -->
<body>
  <!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K329WMFD"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->
  <div class="outer">
    <div class="page-content" id="article">
      <div class="wrapper">
        <div id="hitokoto" class="hitokoto">
          <a href="#" id="hitokoto_text">...... </a>
        </div>
        <div class="hanging-drop">
        </div>
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
      <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Git 常用命令速查</h1>
    <p class="post-meta">
      <span><svg width="10px" height="10px" style="fill: #888; margin-right: 5px; vertical-align: baseline;" viewBox="0 0 16 16"><path d="M2.06 6.69c.14-.4.5-.69.94-.69h11V5c0-.55-.45-1-1-1H6.41l-1.7-1.71A.997.997 0 0 0 4 2H1c-.55 0-1 .45-1 1v9.84l2.05-6.15h.01zM16 8c0-.55-.45-1-1-1H4a.99.99 0 0 0-.94.69l-2 6c-.04.09-.06.2-.06.31 0 .55.45 1 1 1h11c.44 0 .81-.29.94-.69l2-6c.04-.09.06-.2.06-.31z"></path></svg>
      <time datetime="2022-10-30T19:00:00+08:00" itemprop="datePublished">Oct 30, 2022</time></span>
      <a href="/"><span><svg width="10px" height="10px" style="fill: #888; margin-right: 5px; vertical-align: baseline;" viewBox="0 0 16 16"><path d="M1 3h14c.55 0 1-.45 1-1s-.45-1-1-1H1c-.55 0-1 .45-1 1s.45 1 1 1zm14 10H1c-.55 0-1 .45-1 1s.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1zm0-4H1c-.55 0-1 .45-1 1s.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1zm0-4H1c-.55 0-1 .45-1 1s.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1z"></path></svg>Home</span></a>
      <a href="mailto:moselikk@gmail.com"><span><svg width="10px" height="10px" style="fill: #888; margin-right: 5px; vertical-align: baseline;" viewBox="0 0 16 16"><path d="M6 10c-1.1 0-2-.9-2-2V3H1c-.55 0-1 .45-1 1v8c0 .55.45 1 1 1v2a1.003 1.003 0 0 0 1.71.71L5.41 13H10c.55 0 1-.45 1-1v-1.17l-.83-.83H6zm9-10H6c-.55 0-1 .45-1 1v7c0 .55.45 1 1 1h4.59l2.71 2.71c.17.18.42.29.7.29.55 0 1-.45 1-1V9c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1z"></path></svg>Email</span></a>
      <a href="https://github.com/moselikk"><span><svg width="10px" height="10px" style="fill: #888; margin-right: 5px; vertical-align: baseline;" viewBox="0 0 16 16"><path d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>Github</span></a>
      <a href="/excerpt"><span><svg width="10px" height="10px" style="fill: #888; margin-right: 5px; vertical-align: baseline;" viewBox="0 0 16 16"><path d="M11 11c-.28 0-.53.11-.71.29L9 12.59V8c0-.55-.45-1-1-1s-1 .45-1 1v4.59L5.71 11.3A.965.965 0 0 0 5 11a1.003 1.003 0 0 0-.71 1.71l3 3c.18.18.43.29.71.29s.53-.11.71-.29l3-3A1.003 1.003 0 0 0 11 11zm1-7c-.03 0-.07 0-.1.01A5 5 0 0 0 2 5c0 .11.01.22.02.33A3.51 3.51 0 0 0 0 8.5c0 1.41.84 2.61 2.03 3.17C2.2 10.17 3.46 9 5 9c.06 0 .13.02.19.02C5.07 8.7 5 8.36 5 8c0-1.66 1.34-3 3-3s3 1.34 3 3c0 .36-.07.7-.19 1.02.06 0 .13-.02.19-.02 1.48 0 2.7 1.07 2.95 2.47A3.964 3.964 0 0 0 16 8c0-2.21-1.79-4-4-4z"></path></svg>Excerpt</span></a>
      <a href="/about"><span><svg xmlns="http://www.w3.org/2000/svg" width="10px" height="10px" style="fill: #888; margin-right: 5px; vertical-align: baseline;" viewBox="0 0 16 16"><!-- Icon from Tabler Icons by Paweł Kuna - https://github.com/tabler/tabler-icons/blob/master/LICENSE --><path fill="currentColor" d="M18.333 2c1.96 0 3.56 1.537 3.662 3.472l.005.195v12.666c0 1.96-1.537 3.56-3.472 3.662l-.195.005H5.667a3.667 3.667 0 0 1-3.662-3.472L2 18.333V5.667c0-1.96 1.537-3.56 3.472-3.662L5.667 2zM6 15a1 1 0 0 0-1 1v2l.007.117A1 1 0 0 0 7 18v-2l-.007-.117A1 1 0 0 0 6 15m3-4a1 1 0 0 0-1 1v6l.007.117A1 1 0 0 0 10 18v-6l-.007-.117A1 1 0 0 0 9 11m3 2a1 1 0 0 0-1 1v4l.007.117A1 1 0 0 0 13 18v-4l-.007-.117A1 1 0 0 0 12 13"/></svg>About</span></a>
    </p>
  </header>


  

  <div class="post-content" itemprop="articleBody">
    <p>Git 官网：<a href="https://git-scm.com/">https://git-scm.com/</a></p>

<p>官方文档：<a href="https://git-scm.com/docs">https://git-scm.com/docs</a></p>

<p>阮一峰整理：<a href="https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a></p>

<p>全部命令： <a href="https://git-scm.com/docs/git#_git_commands">https://git-scm.com/docs/git#_git_commands</a></p>

<p>GitHub Cheat Sheet：<a href="https://training.github.com/">https://training.github.com/</a></p>

<h2 id="创建仓库">创建仓库</h2>

<p>创建仓库有多种方式，可以直接复制一个已经创建好的仓库的全部文件，git 即刻可用；可以从 github 等远程仓库 clone，克隆的项目 git 也是就绪的；可以使用<code class="language-plaintext highlighter-rouge">git init</code>初始化本地 git 仓库。</p>

<p><code class="language-plaintext highlighter-rouge">$ git init</code></p>

<p>将所在目录初始化为一个 git 仓库</p>

<p><code class="language-plaintext highlighter-rouge">$ git init [project-name]</code></p>

<p>新建一个目录，将其初始化为 Git 仓库</p>

<p><code class="language-plaintext highlighter-rouge">$ git remote add origin [url]</code></p>

<p>链接本地仓库与远程仓库</p>

<p><code class="language-plaintext highlighter-rouge">$ git clone [url]</code></p>

<p>Clone（下载）一个已存在于的仓库和它的整个代码历史</p>

<h2 id="git配置">Git配置</h2>

<p>Git的设置文件为 .gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）</p>

<p><code class="language-plaintext highlighter-rouge">$ git config --list</code></p>

<p>显示当前的 Git 配置</p>

<p><code class="language-plaintext highlighter-rouge">$ git config --global user.name "[name]"</code></p>

<p>对你的 commit 操作设置关联的用户名</p>

<p><code class="language-plaintext highlighter-rouge">$ git config --global user.email "[email address]"</code></p>

<p>对你的 commit 操作设置关联的邮箱地址</p>

<p><code class="language-plaintext highlighter-rouge">$ git config --global color.ui auto</code></p>

<p>启用有帮助的彩色命令行输出</p>

<h2 id="分支">分支</h2>

<p><code class="language-plaintext highlighter-rouge">$ git branch</code></p>

<p>列出所有本地分支</p>

<p><code class="language-plaintext highlighter-rouge">$ git branch -r</code></p>

<p>列出所有远程分支</p>

<p><code class="language-plaintext highlighter-rouge">$ git branch -a</code></p>

<p>列出所有本地分支和远程分支</p>

<p><code class="language-plaintext highlighter-rouge">$ git branch [branch-name]</code></p>

<p>创建分支（但依然停留在当前分支）</p>

<p><code class="language-plaintext highlighter-rouge">$ git checkout -b [branch]</code></p>

<p>新建一个分支，并切换到该分支</p>

<p><code class="language-plaintext highlighter-rouge">$ git checkout [branch-name]</code></p>

<p>切换到指定分支，并更新工作区</p>

<p><code class="language-plaintext highlighter-rouge">$ git switch -c [branch-name]</code></p>

<p>切换到指定分支并更新工作目录 （working directory）（&gt;git 2.23）</p>

<p><code class="language-plaintext highlighter-rouge">$ git checkout -</code></p>

<p>切换到上一个分支</p>

<p><code class="language-plaintext highlighter-rouge">$ git merge [branch]</code></p>

<p>将指定分支的历史合并到当前分支。这通常在拉取请求(PR)中完成，但也是一个重要的 Git 操作。</p>

<p><code class="language-plaintext highlighter-rouge">$ git cherry-pick [commit]</code></p>

<p>选择一个 commit，合并进当前分支</p>

<p><code class="language-plaintext highlighter-rouge">$ git branch -d [branch-name]</code></p>

<p>删除指定分支</p>

<p><code class="language-plaintext highlighter-rouge">$ git push origin --delete [branch-name]</code></p>

<p><code class="language-plaintext highlighter-rouge">$ git branch -dr [remote/branch]</code></p>

<p>删除远程分支</p>

<h2 id="增加删除文件">增加/删除文件</h2>

<p><code class="language-plaintext highlighter-rouge">$ git add [file1] [file2] ...</code></p>

<p>添加指定文件到暂存区</p>

<p><code class="language-plaintext highlighter-rouge">$ git add [dir]</code></p>

<p>添加指定目录到暂存区，包括目录下所有子目录及文件</p>

<p><code class="language-plaintext highlighter-rouge">$ git add .</code></p>

<p>添加当前目录的所有文件到暂存区</p>

<p><code class="language-plaintext highlighter-rouge">$ git add -p</code></p>

<p>添加每个变化前，都会要求确认；对于同一个文件的多处变化，可以实现分次提交（细颗粒度的控制）</p>

<p><code class="language-plaintext highlighter-rouge">$ git rm [file1] [file2] ...</code></p>

<p>删除工作区文件，并且将这次删除放入暂存区</p>

<p><code class="language-plaintext highlighter-rouge">$ git rm --cached [file]</code></p>

<p>停止追踪指定文件，但该文件会保留在工作区</p>

<p><code class="language-plaintext highlighter-rouge">$ git mv [file-original] [file-renamed]</code></p>

<p>改名文件，并且将这个改名放入暂存区</p>

<h2 id="代码提交">代码提交</h2>

<p><code class="language-plaintext highlighter-rouge">$ git commit -m [message]</code></p>

<p>提交暂存区到仓库区</p>

<p><code class="language-plaintext highlighter-rouge">$ git commit [file1] [file2] ... -m [message]</code></p>

<p>提交暂存区的指定文件到仓库区</p>

<p><code class="language-plaintext highlighter-rouge">$ git commit -a</code></p>

<p>提交工作区自上次 commit 之后的变化，直接到仓库区</p>

<p><code class="language-plaintext highlighter-rouge">$ git commit -v</code></p>

<p>提交时显示所有 diff 信息</p>

<p><code class="language-plaintext highlighter-rouge">$ git commit --amend -m [message]</code></p>

<p>使用一次新的 commit，替代上一次提交
如果代码没有任何新变化，则用来改写上一次 commit 的提交信息</p>

<p><code class="language-plaintext highlighter-rouge">$ git commit --amend [file1] [file2] ...</code></p>

<p>重做上一次 commit，并包括指定文件的新变化</p>

<h2 id="远程同步">远程同步</h2>

<p><code class="language-plaintext highlighter-rouge">$ git fetch [remote]</code></p>

<p>下载远程仓库的所有变动</p>

<p><code class="language-plaintext highlighter-rouge">$ git remote -v</code></p>

<p>显示所有远程仓库</p>

<p><code class="language-plaintext highlighter-rouge">$ git remote show [remote]</code></p>

<p>显示某个远程仓库的信息</p>

<p><code class="language-plaintext highlighter-rouge">$ git remote add [shortname] [url]</code></p>

<p>增加一个新的远程仓库，并命名</p>

<p><code class="language-plaintext highlighter-rouge">$ git pull [remote] [branch]</code></p>

<p>取回远程仓库的变化，并与本地分支合并</p>

<p><code class="language-plaintext highlighter-rouge">$ git push [remote] [branch]</code></p>

<p>上传本地指定分支到远程仓库</p>

<p><code class="language-plaintext highlighter-rouge">$ git push [remote] --force</code></p>

<p>强行推送当前分支到远程仓库，即使有冲突</p>

<p><code class="language-plaintext highlighter-rouge">$ git push [remote] --all</code></p>

<p>推送所有分支到远程仓库</p>

<p><code class="language-plaintext highlighter-rouge">$ git push --set-upstream origin my-branch</code></p>

<p>将本地创建的分支推送到远程仓库</p>

<h2 id="撤销">撤销</h2>

<p><code class="language-plaintext highlighter-rouge">$ git checkout [file]</code></p>

<p>恢复暂存区的指定文件到工作区（撤销对 file 文件的修改）</p>

<p><code class="language-plaintext highlighter-rouge">$ git checkout [commit] [file]</code></p>

<p>恢复某个 commit 的指定文件到暂存区和工作区</p>

<p><code class="language-plaintext highlighter-rouge">$ git checkout .</code></p>

<p>恢复暂存区的所有文件到工作区</p>

<p><code class="language-plaintext highlighter-rouge">$ git reset [file]</code></p>

<p>重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变</p>

<p><code class="language-plaintext highlighter-rouge">$ git reset --hard</code></p>

<p>重置暂存区与工作区，与上一次 commit 保持一致</p>

<p><code class="language-plaintext highlighter-rouge">$ git reset [commit]</code></p>

<p>重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变</p>

<p><code class="language-plaintext highlighter-rouge">$ git reset --hard [commit]</code></p>

<p>重置当前分支的 HEAD 为指定 commit，同时重置暂存区和工作区，与指定 commit 一致</p>

<p><code class="language-plaintext highlighter-rouge">$ git reset --keep [commit]</code></p>

<p>重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变</p>

<p><code class="language-plaintext highlighter-rouge">$ git revert [commit]</code></p>

<p>新建一个 commit，用来撤销指定 commit
后者的所有变化都将被前者抵消，并且应用到当前分支</p>

<p><code class="language-plaintext highlighter-rouge">$ git stash</code></p>

<p><code class="language-plaintext highlighter-rouge">$ git stash pop</code></p>

<p>暂时将未提交的变化移除，稍后再移入</p>

<p><code class="language-plaintext highlighter-rouge">$ git reset HEAD^</code></p>

<p>上次提交内容会被保存到工作目录</p>

<p><code class="language-plaintext highlighter-rouge">$ git reset --hard HEAD^</code></p>

<p>上次提交内容会被直接丢弃</p>

<h2 id="标签">标签</h2>

<p><code class="language-plaintext highlighter-rouge">$ git tag</code></p>

<p>列出所有 tag</p>

<p><code class="language-plaintext highlighter-rouge">$ git tag [tag]</code></p>

<p>新建一个 tag 在当前 commit</p>

<p><code class="language-plaintext highlighter-rouge">$ git tag [tag] [commit]</code></p>

<p>新建一个 tag 在指定 commit</p>

<p><code class="language-plaintext highlighter-rouge">$ git tag -d [tag]</code></p>

<p>删除本地 tag</p>

<p><code class="language-plaintext highlighter-rouge">$ git push origin :refs/tags/[tagName]</code></p>

<p>删除远程 tag</p>

<p><code class="language-plaintext highlighter-rouge">$ git show [tag]</code></p>

<p>查看 tag 信息</p>

<p><code class="language-plaintext highlighter-rouge">$ git push [remote] [tag]</code></p>

<p>提交指定 tag</p>

<p><code class="language-plaintext highlighter-rouge">$ git push [remote] --tags</code></p>

<p>提交所有 tag</p>

<p><code class="language-plaintext highlighter-rouge">$ git checkout -b [branch] [tag]</code></p>

<p>新建一个分支，指向某个 tag</p>

<h2 id="查看信息">查看信息</h2>

<p><code class="language-plaintext highlighter-rouge">$ git status</code></p>

<p>显示有变更的文件</p>

<p><code class="language-plaintext highlighter-rouge">$ git log</code></p>

<p>显示当前分支的版本历史</p>

<p><code class="language-plaintext highlighter-rouge">$ git log --stat</code></p>

<p>显示 commit 历史，以及每次 commit 发生变更的文件</p>

<p><code class="language-plaintext highlighter-rouge">$ git log -S [keyword]</code></p>

<p>搜索提交历史，根据关键词</p>

<p><code class="language-plaintext highlighter-rouge">$ git log [tag] HEAD --pretty=format:%s</code></p>

<p>显示某个 commit 之后的所有变动，每个 commit 占据一行</p>

<p><code class="language-plaintext highlighter-rouge">$ git log [tag] HEAD --grep feature</code></p>

<p>显示某个 commit 之后的所有变动，其”提交说明”必须符合搜索条件</p>

<p><code class="language-plaintext highlighter-rouge">$ git log --follow [file]</code></p>

<p><code class="language-plaintext highlighter-rouge">$ git whatchanged [file]</code></p>

<p>显示某个文件的版本历史，包括文件改名</p>

<p><code class="language-plaintext highlighter-rouge">$ git log -p [file]</code></p>

<p>显示指定文件相关的每一次 diff</p>

<p><code class="language-plaintext highlighter-rouge">$ git log -5 --pretty --oneline</code></p>

<p>显示过去 5 次提交</p>

<p><code class="language-plaintext highlighter-rouge">$ git shortlog -sn</code></p>

<p>显示所有提交过的用户，按提交次数排序</p>

<p><code class="language-plaintext highlighter-rouge">$ git blame [file]</code></p>

<p>显示指定文件是什么人在什么时间修改过</p>

<p><code class="language-plaintext highlighter-rouge">$ git diff</code></p>

<p>显示暂存区和工作区的差异</p>

<p><code class="language-plaintext highlighter-rouge">$ git diff --cached [file]</code></p>

<p>显示暂存区和上一个 commit 的差异</p>

<p><code class="language-plaintext highlighter-rouge">$ git diff HEAD</code></p>

<p>显示工作区与当前分支最新 commit 之间的差异</p>

<p><code class="language-plaintext highlighter-rouge">$ git diff [first-branch]...[second-branch]</code></p>

<p>显示两次提交之间的差异</p>

<p><code class="language-plaintext highlighter-rouge">$ git diff --shortstat "@{0 day ago}"</code></p>

<p>显示今天你写了多少行代码</p>

<p><code class="language-plaintext highlighter-rouge">$ git show [commit]</code></p>

<p>显示某次提交的元数据和内容变化</p>

<p><code class="language-plaintext highlighter-rouge">$ git show --name-only [commit]</code></p>

<p>显示某次提交发生变化的文件</p>

<p><code class="language-plaintext highlighter-rouge">$ git show [commit]:[filename]</code></p>

<p>显示某次提交时，某个文件的内容</p>

<p><code class="language-plaintext highlighter-rouge">$ git reflog</code></p>

<p>显示当前分支的最近几次提交</p>

<hr />

<h2 id="命令行中图形化显示提交日志">命令行中图形化显示提交日志</h2>

<p><code class="language-plaintext highlighter-rouge">$ git log --graph --oneline</code></p>

<p>图形化显示当前分支的提交日志</p>

<p><code class="language-plaintext highlighter-rouge">$ git log --graph --patch</code></p>

<p>图形化显示当前分支的提交日志及每次提交的变更内容</p>

<p><code class="language-plaintext highlighter-rouge">$ git log --graph --oneline --all</code></p>

<p>图形化显示所有分支的提交日志</p>

<p><code class="language-plaintext highlighter-rouge">$ git log --graph --patch --all</code></p>

<p>图形化显示所有分支的提交日志及每次提交的变更内容</p>

<h2 id="git-diff">Git diff</h2>

<p><code class="language-plaintext highlighter-rouge">$ git diff</code></p>

<p>比较当前工作区和 Git 的 staging area 里内容的区别</p>

<p><code class="language-plaintext highlighter-rouge">$ git diff --staged</code></p>

<p>比较 Git 的 staging area 和当前分支指向内容的区别</p>

<p><code class="language-plaintext highlighter-rouge">$ git diff &lt;commit&gt; &lt;commit&gt;</code></p>

<p>比较任意两次提交指向内容的区别</p>

<h2 id="git-checkout-和-git-switch-的区别">git checkout 和 git switch 的区别</h2>

<p>是这样的，git checkout 是用于创建和切换分支的旧命令。它还可以用于恢复来自某个提交的修改。但是 git checkout 能做的不仅仅是这些，它还可以让你从任何分支复制文件或直接提交到当前工作区中，而无需切换分支。</p>

<p>实际上，git checkout 做了三件事情：</p>

<p>1）切换分支；</p>

<p>2）从暂存区复制文件到工作区（放弃当前修改）；</p>

<p>3）从其他区复制文件到工作区；</p>

<p>如果你不明白，那没关系，只需要记住：git checkout 能做的不仅仅是分支的切换，还有很多其他额外的功能，而这些额外的功能，增加了 git checkout 这个命令的复杂性。</p>

<p>因此，从 git 2.23 版本发布以后，引入了两个新的命令：git switch 和 git restore。</p>

<p>这样做的目的，是为了让人们使用 git switch 来切换分支，使用 git restore 来撤销本地修改。与此同时，git checkout 仍然被保存，用于提供更高级的选项来处理各种更加复杂的操作。</p>

<p>如果是切换分支，请使用 git switch 命令而不是 git checkout。为什么？因为它就是为这个特定任务创建的。对于新的 git 用户，更容易记住 git switch 用于切换分支，git restore 用于恢复修改。</p>

<p>因此，对于切换和创建分支这个操作来说，使用 git switch 命令替代 git checkout 是被提倡的做法。</p>

<h2 id="git-修改-gitignore-文件-不生效">git 修改 .gitignore 文件 不生效</h2>

<p>原因是 .gitignore 只能忽略那些原来没有被 track 的文件，如果某些文件已经被纳入了版本管理中，则修改 .gitignore 是无效的。那么解决方法就是先把本地缓存删除（改变成未 track 状态），然后再提交：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git <span class="nb">rm</span> <span class="nt">-r</span> <span class="nt">--cached</span> <span class="nb">.</span>
git add <span class="nb">.</span>
git commit <span class="nt">-m</span> <span class="s1">'update .gitignore'</span>
</code></pre></div></div>
<p>停止追踪某文件，重点命令</p>

<p><code class="language-plaintext highlighter-rouge">$ git rm —cached -r [file]</code></p>

<p>停止追踪指定文件，但该文件会保留在工作区</p>

<h2 id="commit-之后-git-自动将-lf-转换成-crlf导致行末-eslint-飘黄">commit 之后 git 自动将 lf 转换成 crlf，导致行末 eslint 飘黄</h2>

<p>修改 git 全局配置，禁止 git 自动将 lf 转换成 crlf</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git config <span class="nt">--global</span> core.autocrlf <span class="nb">false</span>
</code></pre></div></div>

  </div>
<!-- Gitalk 评论系统 -->

<div id="gitalk-container"></div>
<script>
  const gitalk = new Gitalk({
    clientID: '',
    clientSecret: '',
    repo: 'moselikk/moselikk.github.io',
    owner: 'moselikk',
    admin: '["moselikk"]',
    id: 'https://moselikk.com/blog/git-commands', // Ensure uniqueness and length less than 50
    distractionFreeMode: 'false' // Facebook-like distraction free mode
  })
  gitalk.render('gitalk-container')
</script>

</article>

      </div>
    </div>
  </div>
  <script>
    // open outbound links in new tab
    let origin = document.location.origin;
    let links = document.getElementsByTagName("a");
    for (let link of links) {
      if (
        link.href &&
        link.href.indexOf(origin) != 0 &&
        !link.href.includes("mailto:")
      )
        link.setAttribute("target", "_blank");
    }

    // responsive table
    let tables = document.getElementsByTagName("table");
    for (let table of tables) {
      let ths = table.tHead.rows[0].cells;
      let trs = table.tBodies[0].rows;
      for (let row of trs) {
        for (let i = 0; i < row.cells.length; i++) {
          row.cells[i].setAttribute("data-label", ths[i].textContent);
        }
      }
    }

    // hitokoto api
    const rule = ["a", "b","c","d","h","i","j","k"];
    const query = rule.map(item => `c=${item}`).join('&');

      // Function to fetch hitokoto
      function fetchHitokoto() {
      fetch(`https://v1.hitokoto.cn?${query}`)
        .then((response) => response.json())
        .then((data) => {
          const hitokoto = document.getElementById("hitokoto_text");
          hitokoto.href = "https://hitokoto.cn/?uuid=" + data.uuid;
          const from = data.from ? " -" + data.from : ''
          hitokoto.innerText = data.hitokoto + from;
          // Store the timestamp and result of the last API call
          localStorage.setItem('lastHitokotoCall', Date.now());
          localStorage.setItem('lastHitokotoResult', JSON.stringify(data));
        })
        .catch(console.error);
    }

    // Function to use the last hitokoto result
    function useLastHitokotoResult() {
      const data = JSON.parse(localStorage.getItem('lastHitokotoResult'));
      const hitokoto = document.getElementById("hitokoto_text");
      hitokoto.href = "https://hitokoto.cn/?uuid=" + data.uuid;
      hitokoto.innerText = data.hitokoto;
    }

    // Check if we can call the API
    function canCallHitokoto() {
      const lastCall = localStorage.getItem('lastHitokotoCall');
      const now = Date.now();
      // Check if the last call was more than a minute ago
      return !lastCall || now - lastCall > 60 * 1000;
    }

    // Main logic
    if (canCallHitokoto()) {
      fetchHitokoto();
    } else {
      const lastResult = localStorage.getItem('lastHitokotoResult');
      if (lastResult) {
        useLastHitokotoResult();
      } else {
        fetchHitokoto();
      }
    }
  </script>
  <!-- <script src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon='{"token": ""}'
    onerror="gtag('set', 'user_properties', {blocker: 'true'});"></script> -->
  <script src="/js/zooming.min.js"></script>
  <script>
    if (window.Zooming && typeof screen.orientation == "undefined")
      window.addEventListener("load", function () {
        new Zooming().listen(".post-content img");
      });
  </script>
  <script src="../js/denglong.js"></script>
</body>

</html>